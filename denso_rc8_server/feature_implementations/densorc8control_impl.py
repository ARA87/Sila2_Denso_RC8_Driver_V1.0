# Generated by sila2.code_generator; adapted to legacy controller
from __future__ import annotations

import logging
import time
from datetime import timedelta
from typing import TYPE_CHECKING, List, Optional

from sila2.server import MetadataDict, ObservableCommandInstance
from sila2.framework.errors.undefined_execution_error import UndefinedExecutionError
from .pybcapclient.orinexception import ORiNException

from .driver.denso_rc8_controller import DensoRC8Controller

from ..generated.densorc8control import (
    ConfigureConnection_Responses,
    DensoRC8ControlBase,
    GetFValue_Responses,
    GetIOValue_Responses,
    GetIValue_Responses,
    GetJValue_Responses,
    GetPosValue_Responses,
    GetProgram_Responses,
    GetPValue_Responses,
    GetSValue_Responses,
    GetVValue_Responses,
    SetFValue_Responses,
    SetIOValue_Responses,
    SetIValue_Responses,
    SetJValue_Responses,
    SetPValue_Responses,
    SetSValue_Responses,
    SetVValue_Responses,
    Start_Responses,
    StartProgram_Responses,
    StopProgram_Responses,
    ClearError_Responses,
)

if TYPE_CHECKING:
    from ..server import Server

# ---- DENSO @STATUS Codes ----
STATUS_NON_EXISTENT = 0
STATUS_HOLD_STOPPED = 1
STATUS_STOPPED = 2
STATUS_RUNNING = 3
STATUS_STEP_STOPPED = 4
END_STATES = {STATUS_HOLD_STOPPED, STATUS_STOPPED, STATUS_STEP_STOPPED}


class DensoRC8ControlImpl(DensoRC8ControlBase):
    """
    - Observable property STATUS with active push via update_STATUS(...)
    - StartProgram waits (except in continuous mode) for program termination via @STATUS
    - ORiN error -> UndefinedExecutionError (only if b-CAP throws)
    """

    def __init__(self, parent_server: Server) -> None:
        super().__init__(parent_server=parent_server)
        self.controller = DensoRC8Controller()
        self.StartProgram_default_lifetime_of_execution = timedelta(minutes=30)

        # last published STATUS (for initial push)
        self._last_status: Optional[int] = None

        def _poll_status() -> None:
            """
            Read & push only – NO get_program() here!
            Handles must be configured in GetProgram/StartProgram beforehand.
            """
            prog = getattr(self.controller, "current_program_name", None)
            if not prog:
                return
            task_vars = getattr(self.controller, "task_status_vars", {})
            var_handle = task_vars.get(prog)
            if not var_handle:
                return
            try:
                cur = int(self.controller.bcap.variable_getvalue(var_handle))
            except Exception as e:
                logging.debug("STATUS poll read failed: %r", e)
                return

            if self._last_status is None or cur != self._last_status:
                self._last_status = cur
                try:
                    self.update_STATUS(cur)
                except Exception as e:
                    logging.debug("update_STATUS failed: %r", e)

        # Polling alle 200ms
        self.run_periodically(_poll_status, delay_seconds=0.2)

    # ---------------------- Connection / Lifecycle ----------------------

    def ConfigureConnection(
        self, IPAddress: str, Port: int, Timeout: int, *, metadata: MetadataDict
    ) -> ConfigureConnection_Responses:
        self.controller.configure_connection(ip=IPAddress, port=Port, timeout=Timeout)
        return ConfigureConnection_Responses()

    def Start(self, *, metadata: MetadataDict) -> Start_Responses:
        try:
            self.controller.start()
        except ORiNException as e:
            self._raise_with_controller_error("Start", e)
        return Start_Responses()

    # ---------------------- IO-Variables ----------------------

    def SetIOValue(self, Index: int, Value: int, *, metadata: MetadataDict) -> SetIOValue_Responses:
        self.controller.set_IO_value(Index=Index, value=Value)
        return SetIOValue_Responses()

    def GetIOValue(self, Index: int, *, metadata: MetadataDict) -> GetIOValue_Responses:
        value = self.controller.get_IO_value(Index=Index)
        return GetIOValue_Responses(Value=value)

    # ---------------------- S-Variables ----------------------

    def SetSValue(self, Index: int, Value: str, *, metadata: MetadataDict) -> SetSValue_Responses:
        self.controller.set_s_value(Index=Index, value=Value)
        return SetSValue_Responses()

    def GetSValue(self, Index: int, *, metadata: MetadataDict) -> GetSValue_Responses:
        value = self.controller.get_s_value(Index=Index)
        return GetSValue_Responses(Value=value)

    # ---------------------- I-Variables ----------------------

    def SetIValue(self, Index: int, Value: int, *, metadata: MetadataDict) -> SetIValue_Responses:
        self.controller.set_I_value(Index=Index, value=Value)
        return SetIValue_Responses()

    def GetIValue(self, Index: int, *, metadata: MetadataDict) -> GetIValue_Responses:
        value = self.controller.get_I_value(Index=Index)
        return GetIValue_Responses(Value=value)

    # ---------------------- F-Variables ----------------------

    def SetFValue(self, Index: int, Value: float, *, metadata: MetadataDict) -> SetFValue_Responses:
        self.controller.set_F_value(Index=Index, value=Value)
        return SetFValue_Responses()

    def GetFValue(self, Index: int, *, metadata: MetadataDict) -> GetFValue_Responses:
        value = self.controller.get_F_value(Index=Index)
        return GetFValue_Responses(Value=value)

    # ---------------------- P-Variables ----------------------

    def SetPValue(self, Index: int, Value: List[float], *, metadata: MetadataDict) -> SetPValue_Responses:
        self.controller.set_P_value(Index=Index, value=Value)
        return SetPValue_Responses()

    def GetPValue(self, Index: int, *, metadata: MetadataDict) -> GetPValue_Responses:
        value = self.controller.get_P_value(Index=Index)
        return GetPValue_Responses(Value=value)

    # ---------------------- J-Variables ----------------------

    def SetJValue(self, Index: int, Value: List[float], *, metadata: MetadataDict) -> SetJValue_Responses:
        self.controller.set_J_value(Index=Index, value=Value)
        return SetJValue_Responses()

    def GetJValue(self, Index: int, *, metadata: MetadataDict) -> GetJValue_Responses:
        value = self.controller.get_J_value(Index=Index)
        return GetJValue_Responses(Value=value)

    # ---------------------- V-Variables ----------------------

    def SetVValue(self, Index: int, Value: List[float], *, metadata: MetadataDict) -> SetVValue_Responses:
        self.controller.set_V_value(Index=Index, value=Value)
        return SetVValue_Responses()

    def GetVValue(self, Index: int, *, metadata: MetadataDict) -> GetVValue_Responses:
        value = self.controller.get_V_value(Index=Index)
        return GetVValue_Responses(Value=value)

    # ---------------------- Position ----------------------

    def GetPosValue(self, *, metadata: MetadataDict) -> GetPosValue_Responses:
        value = self.controller.get_pos_value()
        return GetPosValue_Responses(Value=value)

    # ---------------------- Program Control ----------------------

    def GetProgram(self, ProgramName: str, *, metadata: MetadataDict) -> GetProgram_Responses:
        """    
        Set up program handle + @STATUS and push initial STATUS
        """
        try:
            self.controller.get_program(program_name=ProgramName)
            setattr(self.controller, "current_program_name", ProgramName)

            # Initialen STATUS lesen & pushen
            var_handle = self.controller.task_status_vars.get(ProgramName)
            if var_handle:
                try:
                    cur = int(self.controller.bcap.variable_getvalue(var_handle))
                    self._last_status = cur
                    self.update_STATUS(cur)
                except Exception as e:
                    logging.debug("GetProgram: initial @STATUS read failed: %r", e)

            return GetProgram_Responses()
        except ORiNException as e:
            self._raise_with_controller_error("GetProgram", e)

    def StopProgram(self, ProgramName: str, Mode: str, *, metadata: MetadataDict) -> StopProgram_Responses:
        try:
            # Ensure handle (without poller side effect)
            self.controller.get_program(program_name=ProgramName)
            setattr(self.controller, "current_program_name", ProgramName)
            self.controller.stop_program(program_name=ProgramName, mode=Mode)
            return StopProgram_Responses()
        except ORiNException as e:
            self._raise_with_controller_error("StopProgram", e)


    def ClearError(self, *, metadata: MetadataDict) -> ClearError_Responses:
        try:
            self.controller.bcap.controller_execute(self.controller.h_ctrl, "ClearError")
            return ClearError_Responses()
        except ORiNException as e:
            self._raise_with_controller_error("ClearError", e)

    def StartProgram(
        self, ProgramName: str, Mode: str, *, metadata: MetadataDict, instance: ObservableCommandInstance
    ) -> StartProgram_Responses:
        """
        Starts a program, monitors its @STATUS (instance-local), and terminates the observable instance
        reliably – even with parallel calls.

        Terminal states:
        - HOLD_STOPPED (1) -> "HoldStopped"
        - STOPPED (2) -> "Completed"
        - STEP_STOPPED (4) -> "Completed(Step)"

        - In case of ORiN errors *during startup*, @ERROR_DESCRIPTION is read with a short retry and output.
        - "The operation completed successfully." is NOT interpreted as an error.
        """
        instance.begin_execution()

        # ---- DENSO status constants (if not defined globally) ----
        STATUS_NON_EXISTENT = 0
        STATUS_HOLD_STOPPED = 1
        STATUS_STOPPED      = 2
        STATUS_RUNNING      = 3
        STATUS_STEP_STOPPED = 4
        END_STATES = {STATUS_HOLD_STOPPED, STATUS_STOPPED, STATUS_STEP_STOPPED}

        # 1) Save program/handles locally (no global dependency)
        try:
            self.controller.get_program(program_name=ProgramName)
            task_handle = self.controller.task_handles[ProgramName]
            status_handle = self.controller.task_status_vars[ProgramName]
        except ORiNException as e:
            self._raise_with_controller_error("StartProgram/get_program", e)

        # Optional: Set property focus (has no effect on this instance)
        try:
            setattr(self.controller, "current_program_name", ProgramName)
        except Exception:
            pass

        # --- helper: @ERROR_DESCRIPTION read once ---
        def _read_controller_err_text_once() -> str:
            try:
                var_ed = self.controller.bcap.controller_getvariable(self.controller.h_ctrl, "@ERROR_DESCRIPTION", "")
                txt = self.controller.bcap.variable_getvalue(var_ed)
                if txt:
                    txt = str(txt).strip()
                    if txt.lower() == "the operation completed successfully.":
                        return ""
                    return txt
            except Exception:
                pass
            return ""

        # 2) Start – here the immediate error text must be captured
        try:
            self.controller.start_program(program_name=ProgramName, mode=Mode)
        except ORiNException as e:
            # Short retry window because RC8 likes to set the text with a minimal delay
            desc = ""
            for _ in range(6):  # ~ 6 * 80ms = ~0,5s
                desc = _read_controller_err_text_once()
                if desc:
                    break
                time.sleep(0.08)

            # If controller text is empty: optionally try task-side (@ERROR_DESCRIPTION)
            if not desc and task_handle is not None:
                try:
                    v = self.controller.bcap.task_getvariable(task_handle, "@ERROR_DESCRIPTION", "")
                    t = self.controller.bcap.variable_getvalue(v)
                    if t:
                        t = str(t).strip()
                        if t.lower() != "the operation completed successfully.":
                            desc = t
                except Exception:
                    pass

            # Build ErrorMessage
            msg = f"StartProgram: ORiNException {e}"
            if desc:
                msg += f" — {desc}"
            raise UndefinedExecutionError(msg)

        # 3) Local monitoring loop: read ONLY your own status_handle
        poll_dt = 0.1
        max_run_s = 60 * 10  # 10 Minutes limit
        t0 = time.time()
        progress = 0.0

        # small debouncing for final states
        confirm_needed = 3
        confirm_count = 0
        last_cur = None

        while True:
            if time.time() - t0 > max_run_s:
                raise UndefinedExecutionError(f"StartProgram '{ProgramName}' timeout after {max_run_s}s")

            try:
                cur = int(self.controller.bcap.variable_getvalue(status_handle))
            except Exception:
                time.sleep(poll_dt)
                continue

            # Progress während RUNNING sanft hochziehen, aber < 1.0 lassen
            if cur == STATUS_RUNNING:
                if progress < 0.95:
                    progress = min(0.95, progress + 0.05)
                    try:
                        instance.progress = progress
                    except Exception:
                        pass
                # Endzustands-Entprellung zurücksetzen
                confirm_count = 0
                last_cur = cur

            elif cur in END_STATES:
                # Entprellen
                if cur == last_cur:
                    confirm_count += 1
                else:
                    confirm_count = 1
                    last_cur = cur

                if confirm_count >= confirm_needed:
                    # finaler Abschluss
                    try:
                        instance.progress = 1.0
                    except Exception:
                        pass

                    # --- Check for errors first at EVERY STOPPED ---
                    # (1) One-time controller error text
                    err_txt = _read_controller_err_text_once()
                    if err_txt:
                        raise UndefinedExecutionError(f"Program '{ProgramName}' failed: {err_txt}")

                    # (2) RC8-error_stack / @ERROR_CODE
                    has_err, msg = self._read_rc8_error()
                    if has_err:
                        raise UndefinedExecutionError(f"Program '{ProgramName}' failed: {msg}")

                    # --- No error detected: complete successfully as before ---
                    if cur == STATUS_STOPPED:
                        return StartProgram_Responses(Status="Completed")

                    if cur == STATUS_STEP_STOPPED:
                        return StartProgram_Responses(Status="Completed(Step)")

                    if cur == STATUS_HOLD_STOPPED:
                        # for example after „Cont. Stop“/Stop-Button on TP
                        return StartProgram_Responses(Status="HoldStopped")

            else:
                # other States (z.B. NON_EXISTENT) – just keep polling
                confirm_count = 0
                last_cur = cur

            time.sleep(poll_dt)

    # ---------------------- Observable Property Hook ----------------------

    def STATUS_on_subscription(self, *, metadata: MetadataDict) -> None:
        if self._last_status is not None:
            try:
                self.update_STATUS(self._last_status)
            except Exception:
                logging.debug("STATUS_on_subscription: initial push skipped")
        return super().STATUS_on_subscription(metadata=metadata)

    # ---------------------- Helpers ----------------------

    def _raise_with_controller_error(self, ctx: str, orin_exc: ORiNException) -> None:
        err_desc = ""
        try:
            err_var = self.controller.bcap.controller_getvariable(self.controller.h_ctrl, "@ERROR_DESCRIPTION", "")
            err_desc = self.controller.bcap.variable_getvalue(err_var)
        except Exception as exc:
            logging.warning(f"[{ctx}] Error while read @ERROR_DESCRIPTION: {exc}")
        raise UndefinedExecutionError(f"{ctx}: ORiNException {orin_exc} - Controller-Error: {err_desc}")

    # ---- Helper: RC8-Error read (b-CAP) ----
    def _read_rc8_error(self):
        """
        Delivers (has_error, message).
        1) Error_stack (GetCurErrorCount/GetCurErrorInfo(0))
        2) @ERROR_CODE/@ERROR_DESCRIPTION
        """
        # 1) ErrorStack
        try:
            cnt = self.controller.bcap.controller_execute(self.controller.h_ctrl, "GetCurErrorCount", "")
            if cnt and int(cnt) > 0:
                info = self.controller.bcap.controller_execute(self.controller.h_ctrl, "GetCurErrorInfo", 0)
                # info: [code, message, subcode, fileIdLine, programName, lineNo, fileId]
                code = info[0] if len(info) > 0 else None
                msg  = info[1] if len(info) > 1 else ""
                return True, f"RC8 error {code}: {msg}"
        except Exception:
            pass  # Read errors should not crash the command

        # 2) Systemvariables
        try:
            h_code = self.controller.bcap.controller_getvariable(self.controller.h_ctrl, "@ERROR_CODE", "")
            err_code = self.controller.bcap.variable_getvalue(h_code)
            if err_code is not None and int(err_code) != 0:
                h_desc = self.controller.bcap.controller_getvariable(self.controller.h_ctrl, "@ERROR_DESCRIPTION", "")
                desc = self.controller.bcap.variable_getvalue(h_desc)
                desc = (str(desc) if desc is not None else "").strip()
                return True, f"RC8 error {int(err_code)}: {desc or 'No description'}"
        except Exception:
            pass

        return False, ""

    # ---------------------- Lifecycle Hooks ----------------------

    def start(self):
        super().start()
        print("🟢 Feature DensoRC8 started")

    def stop(self):
        print("🔴 Feature DensoRC8 stopped")
        super().stop()
