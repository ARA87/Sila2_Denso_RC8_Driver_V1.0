# Generated by sila2.code_generator; adapted to legacy controller
from __future__ import annotations

import logging
import time
from datetime import timedelta
from typing import TYPE_CHECKING, List, Optional, Tuple, Callable, Any, TypeVar, cast
from functools import wraps

from sila2.server import MetadataDict, ObservableCommandInstance
from sila2.framework.errors.undefined_execution_error import UndefinedExecutionError

# --- Robust: ORiNException aus beiden möglichen Pfaden importieren ---
_ORIN_TYPES: tuple = ()
try:
    # Pfad A: über driver/ eingebunden
    from .driver.pybcapclient.orinexception import ORiNException as ORiN_A  # type: ignore
    _ORIN_TYPES = _ORIN_TYPES + (ORiN_A,)
except Exception:
    pass
try:
    # Pfad B: direkt unter feature_implementations
    from .pybcapclient.orinexception import ORiNException as ORiN_B  # type: ignore
    _ORIN_TYPES = _ORIN_TYPES + (ORiN_B,)
except Exception:
    pass

def _is_orin_exception(exc: BaseException) -> bool:
    if _ORIN_TYPES and isinstance(exc, _ORIN_TYPES):
        return True
    return exc.__class__.__name__ == "ORiNException"

from .driver.denso_rc8_controller import DensoRC8Controller

from ..generated.densorc8control import (
    ConfigureConnection_Responses,
    DensoRC8ControlBase,
    GetFValue_Responses,
    GetIOValue_Responses,
    GetIValue_Responses,
    GetJValue_Responses,
    GetPosValue_Responses,
    GetProgram_Responses,
    GetPValue_Responses,
    GetSValue_Responses,
    GetVValue_Responses,
    SetFValue_Responses,
    SetIOValue_Responses,
    SetIValue_Responses,
    SetJValue_Responses,
    SetPValue_Responses,
    SetSValue_Responses,
    SetVValue_Responses,
    Start_Responses,
    StartProgram_Responses,
    StopProgram_Responses,
    ClearError_Responses,
)

if TYPE_CHECKING:
    from ..server import Server

# ---- DENSO @STATUS Codes ----
STATUS_NON_EXISTENT = 0
STATUS_HOLD_STOPPED = 1
STATUS_STOPPED = 2
STATUS_RUNNING = 3
STATUS_STEP_STOPPED = 4
END_STATES = {STATUS_HOLD_STOPPED, STATUS_STOPPED, STATUS_STEP_STOPPED}

F = TypeVar("F", bound=Callable[..., Any])

def catch_orin(ctx: str) -> Callable[[F], F]:
    """
    Dekorator: fängt JEDE Exception, erkennt ORiNException (egal aus welchem Modulpfad),
    übersetzt sie andernfalls unverändert weiter.
    """
    def decorator(fn: F) -> F:
        @wraps(fn)
        def wrapper(self: "DensoRC8ControlImpl", *args, **kwargs):
            try:
                return fn(self, *args, **kwargs)
            except Exception as e:  # breit, um alle ORiN-Pfade zu erwischen
                if _is_orin_exception(e):
                    raise UndefinedExecutionError(self._format_orin_error(ctx, e))
                raise
        return cast(F, wrapper)
    return decorator


class DensoRC8ControlImpl(DensoRC8ControlBase):
    """
    - STATUS-Observable mit aktivem Push
    - StartProgram: kein internes Timeout; @STATUS wird überwacht, bis Endzustand
    - JEDE ORiNException wird zentral in Klartext übersetzt (HRESULT + GetErrorDescription + RC8-ErrorStack)
    """

    def __init__(self, parent_server: Server) -> None:
        super().__init__(parent_server=parent_server)
        self.controller = DensoRC8Controller()

        # Lebensdauer der Observable-Instanz großzügig setzen (hier: 7 Tage)
        # => verhindert, dass der Server die Instanz vorzeitig beendet.
        self.StartProgram_default_lifetime_of_execution = timedelta(days=7)

        # last published STATUS (for initial push)
        self._last_status: Optional[int] = None

        def _poll_status() -> None:
            """
            Read & push only – NO get_program() here!
            Handles must be configured in GetProgram/StartProgram beforehand.
            """
            prog = getattr(self.controller, "current_program_name", None)
            if not prog:
                return
            task_vars = getattr(self.controller, "task_status_vars", {})
            var_handle = task_vars.get(prog)
            if not var_handle:
                return
            try:
                cur = int(self.controller.bcap.variable_getvalue(var_handle))
            except Exception as e:
                logging.debug("STATUS poll read failed: %r", e)
                return

            if self._last_status is None or cur != self._last_status:
                self._last_status = cur
                try:
                    self.update_STATUS(cur)
                except Exception as e:
                    logging.debug("update_STATUS failed: %r", e)

        # Polling alle 200ms
        self.run_periodically(_poll_status, delay_seconds=0.2)

    # ---------------------- Connection / Lifecycle ----------------------

    @catch_orin("ConfigureConnection")
    def ConfigureConnection(
        self, IPAddress: str, Port: int, Timeout: int, *, metadata: MetadataDict
    ) -> ConfigureConnection_Responses:
        self.controller.configure_connection(ip=IPAddress, port=Port, timeout=Timeout)
        return ConfigureConnection_Responses()

    @catch_orin("Start")
    def Start(self, *, metadata: MetadataDict) -> Start_Responses:
        self.controller.start()
        return Start_Responses()

    # ---------------------- IO-Variables ----------------------

    @catch_orin("SetIOValue")
    def SetIOValue(self, Index: int, Value: int, *, metadata: MetadataDict) -> SetIOValue_Responses:
        self.controller.set_IO_value(Index=Index, value=Value)
        return SetIOValue_Responses()

    @catch_orin("GetIOValue")
    def GetIOValue(self, Index: int, *, metadata: MetadataDict) -> GetIOValue_Responses:
        value = self.controller.get_IO_value(Index=Index)
        return GetIOValue_Responses(Value=value)

    # ---------------------- S-Variables ----------------------

    @catch_orin("SetSValue")
    def SetSValue(self, Index: int, Value: str, *, metadata: MetadataDict) -> SetSValue_Responses:
        self.controller.set_s_value(Index=Index, value=Value)
        return SetSValue_Responses()

    @catch_orin("GetSValue")
    def GetSValue(self, Index: int, *, metadata: MetadataDict) -> GetSValue_Responses:
        value = self.controller.get_s_value(Index=Index)
        return GetSValue_Responses(Value=value)

    # ---------------------- I-Variables ----------------------

    @catch_orin("SetIValue")
    def SetIValue(self, Index: int, Value: int, *, metadata: MetadataDict) -> SetIValue_Responses:
        self.controller.set_I_value(Index=Index, value=Value)
        return SetIValue_Responses()

    @catch_orin("GetIValue")
    def GetIValue(self, Index: int, *, metadata: MetadataDict) -> GetIValue_Responses:
        value = self.controller.get_I_value(Index=Index)
        return GetIValue_Responses(Value=value)

    # ---------------------- F-Variables ----------------------

    @catch_orin("SetFValue")
    def SetFValue(self, Index: int, Value: float, *, metadata: MetadataDict) -> SetFValue_Responses:
        self.controller.set_F_value(Index=Index, value=Value)
        return SetFValue_Responses()

    @catch_orin("GetFValue")
    def GetFValue(self, Index: int, *, metadata: MetadataDict) -> GetFValue_Responses:
        value = self.controller.get_F_value(Index=Index)
        return GetFValue_Responses(Value=value)

    # ---------------------- P-Variables ----------------------

    @catch_orin("SetPValue")
    def SetPValue(self, Index: int, Value: List[float], *, metadata: MetadataDict) -> SetPValue_Responses:
        self.controller.set_P_value(Index=Index, value=Value)
        return SetPValue_Responses()

    @catch_orin("GetPValue")
    def GetPValue(self, Index: int, *, metadata: MetadataDict) -> GetPValue_Responses:
        value = self.controller.get_P_value(Index=Index)
        return GetPValue_Responses(Value=value)

    # ---------------------- J-Variables ----------------------

    @catch_orin("SetJValue")
    def SetJValue(self, Index: int, Value: List[float], *, metadata: MetadataDict) -> SetJValue_Responses:
        self.controller.set_J_value(Index=Index, value=Value)
        return SetJValue_Responses()

    @catch_orin("GetJValue")
    def GetJValue(self, Index: int, *, metadata: MetadataDict) -> GetJValue_Responses:
        value = self.controller.get_J_value(Index=Index)
        return GetJValue_Responses(Value=value)

    # ---------------------- V-Variables ----------------------

    @catch_orin("SetVValue")
    def SetVValue(self, Index: int, Value: List[float], *, metadata: MetadataDict) -> SetVValue_Responses:
        self.controller.set_V_value(Index=Index, value=Value)
        return SetVValue_Responses()

    @catch_orin("GetVValue")
    def GetVValue(self, Index: int, *, metadata: MetadataDict) -> GetVValue_Responses:
        value = self.controller.get_V_value(Index=Index)
        return GetVValue_Responses(Value=value)

    # ---------------------- Position ----------------------

    @catch_orin("GetPosValue")
    def GetPosValue(self, *, metadata: MetadataDict) -> GetPosValue_Responses:
        value = self.controller.get_pos_value()
        return GetPosValue_Responses(Value=value)

    # ---------------------- Program Control ----------------------

    @catch_orin("GetProgram")
    def GetProgram(self, ProgramName: str, *, metadata: MetadataDict) -> GetProgram_Responses:
        """Bindet Handle + @STATUS und pusht initialen STATUS."""
        self.controller.get_program(program_name=ProgramName)
        setattr(self.controller, "current_program_name", ProgramName)

        var_handle = self.controller.task_status_vars.get(ProgramName)
        if var_handle:
            try:
                cur = int(self.controller.bcap.variable_getvalue(var_handle))
                self._last_status = cur
                self.update_STATUS(cur)
            except Exception as e:
                logging.debug("GetProgram: initial @STATUS read failed: %r", e)

        return GetProgram_Responses()

    @catch_orin("StopProgram")
    def StopProgram(self, ProgramName: str, Mode: str, *, metadata: MetadataDict) -> StopProgram_Responses:
        setattr(self.controller, "current_program_name", ProgramName)
        self.controller.stop_program(program_name=ProgramName, mode=Mode)
        return StopProgram_Responses()

    @catch_orin("ClearError")
    def ClearError(self, *, metadata: MetadataDict) -> ClearError_Responses:
        self.controller.bcap.controller_execute(self.controller.h_ctrl, "ClearError")
        return ClearError_Responses()

    @catch_orin("StartProgram")
    def StartProgram(
        self, ProgramName: str, Mode: str, *, metadata: MetadataDict, instance: ObservableCommandInstance
    ) -> StartProgram_Responses:
        """
        Startet ein Programm, überwacht @STATUS und beendet die Observable-Instanz sauber.
        KEIN internes Timeout – die Schleife läuft, bis ein Endzustand erreicht ist
        (oder die SiLA-Instanz-Lifetime abläuft, z. B. nach 7 Tagen).
        """
        instance.begin_execution()

        STATUS_NON_EXISTENT = 0
        STATUS_HOLD_STOPPED = 1
        STATUS_STOPPED      = 2
        STATUS_RUNNING      = 3
        STATUS_STEP_STOPPED = 4
        END_STATES = {STATUS_HOLD_STOPPED, STATUS_STOPPED, STATUS_STEP_STOPPED}

        # Handle & Status-Var holen (ORiN wird zentral gefangen)
        self.controller.get_program(program_name=ProgramName)
        task_handle = self.controller.task_handles[ProgramName]
        status_handle = self.controller.task_status_vars[ProgramName]

        setattr(self.controller, "current_program_name", ProgramName)

        # Start
        self.controller.start_program(program_name=ProgramName, mode=Mode)

        # Monitoring-Loop (ohne hartes Timeout)
        poll_dt = 0.1
        progress = 0.0
        confirm_needed = 3
        confirm_count = 0
        last_cur = None

        def _read_error_description_once() -> str:
            try:
                var_ed = self.controller.bcap.controller_getvariable(self.controller.h_ctrl, "@ERROR_DESCRIPTION", "")
                txt = self.controller.bcap.variable_getvalue(var_ed)
                if txt:
                    txt = str(txt).strip()
                    if txt.lower() == "the operation completed successfully.":
                        return ""
                    return txt
            except Exception:
                pass
            return ""

        while True:
            try:
                cur = int(self.controller.bcap.variable_getvalue(status_handle))
            except Exception:
                time.sleep(poll_dt)
                continue

            if cur == STATUS_RUNNING:
                if progress < 0.95:
                    progress = min(0.95, progress + 0.05)
                    try:
                        instance.progress = progress
                    except Exception:
                        pass
                confirm_count = 0
                last_cur = cur

            elif cur in END_STATES:
                if cur == last_cur:
                    confirm_count += 1
                else:
                    confirm_count = 1
                    last_cur = cur

                if confirm_count >= confirm_needed:
                    try:
                        instance.progress = 1.0
                    except Exception:
                        pass

                    # (A) Controller-Text einmalig prüfen
                    err_txt = _read_error_description_once()
                    if err_txt:
                        raise UndefinedExecutionError(f"Program '{ProgramName}' failed: {err_txt}")

                    # (B) RC8-ErrorStack prüfen
                    has_err, msg = self._read_rc8_error_stack()
                    if has_err:
                        raise UndefinedExecutionError(f"Program '{ProgramName}' failed: {msg}")

                    if cur == STATUS_STOPPED:
                        return StartProgram_Responses(Status="Completed")
                    if cur == STATUS_STEP_STOPPED:
                        return StartProgram_Responses(Status="Completed(Step)")
                    if cur == STATUS_HOLD_STOPPED:
                        return StartProgram_Responses(Status="HoldStopped")

            else:
                confirm_count = 0
                last_cur = cur

            time.sleep(poll_dt)

    # ---------------------- Observable Property Hook ----------------------

    def STATUS_on_subscription(self, *, metadata: MetadataDict) -> None:
        if self._last_status is not None:
            try:
                self.update_STATUS(self._last_status)
            except Exception:
                logging.debug("STATUS_on_subscription: initial push skipped")
        return super().STATUS_on_subscription(metadata=metadata)

    # ---------------------- Zentrale Fehlerübersetzung ----------------------

    def _format_orin_error(self, ctx: str, exc: BaseException, *, retries: int = 6, sleep_s: float = 0.08) -> str:
        """
        Liefert eine aussagekräftige Fehlermeldung:
          - HRESULT dec/hex (falls verfügbar)
          - GetErrorDescription(HRESULT)
          - ggf. RC8 ErrorStack (GetCurErrorInfo) oder @ERROR_CODE/@ERROR_DESCRIPTION
        """
        # HRESULT
        hr_int = None
        try:
            hr_int = int(getattr(exc, "args", [None])[0])
        except Exception:
            hr_int = None
        hr_hex = f"0x{hr_int & 0xFFFFFFFF:08X}" if isinstance(hr_int, int) else "n/a"

        # kurze Wartezeit, damit RC8 ggf. den Fehlerstack setzt
        has_err, stack_msg = False, ""
        for _ in range(retries):
            has_err, stack_msg = self._read_rc8_error_stack()
            if has_err:
                break
            time.sleep(sleep_s)
        if not has_err:
            has_err, stack_msg = self._read_rc8_error_stack()

        # Zusatz: @ERROR_CODE/@ERROR_DESCRIPTION falls kein Stack
        if not has_err:
            try:
                h_code = self.controller.bcap.controller_getvariable(self.controller.h_ctrl, "@ERROR_CODE", "")
                code = self.controller.bcap.variable_getvalue(h_code)
                if code is not None and int(code) != 0:
                    h_desc = self.controller.bcap.controller_getvariable(self.controller.h_ctrl, "@ERROR_DESCRIPTION", "")
                    desc = self.controller.bcap.variable_getvalue(h_desc)
                    desc = (str(desc) if desc is not None else "").strip()
                    has_err, stack_msg = True, f"RC8 error {int(code)}: {desc or 'No description'}"
            except Exception:
                pass

        # Klartext zum HRESULT
        hr_text = ""
        if isinstance(hr_int, int):
            try:
                hr_text = self.controller.bcap.controller_execute(self.controller.h_ctrl, "GetErrorDescription", int(hr_int))
                hr_text = (str(hr_text) if hr_text is not None else "").strip()
            except Exception:
                hr_text = ""

        base = f"{ctx} failed: ORiN {hr_int if hr_int is not None else 'n/a'} ({hr_hex})"
        parts = [base]
        if hr_text:
            parts.append(hr_text)
        if has_err and stack_msg:
            parts.append(stack_msg)
        return " — ".join(parts)

    def _read_rc8_error_stack(self) -> Tuple[bool, str]:
        """
        (has_error, message) – Controller-Fehlerstack:
          GetCurErrorCount / GetCurErrorInfo(0)
        """
        try:
            cnt = self.controller.bcap.controller_execute(self.controller.h_ctrl, "GetCurErrorCount", "")
            if cnt and int(cnt) > 0:
                info = self.controller.bcap.controller_execute(self.controller.h_ctrl, "GetCurErrorInfo", 0)
                # info: [code, message, subcode, fileIdLine, programName, lineNo, fileId]
                code = info[0] if len(info) > 0 else None
                msg  = info[1] if len(info) > 1 else ""
                prog = info[4] if len(info) > 4 else ""
                line = info[5] if len(info) > 5 else ""
                details = f"RC8 error {code}: {msg}"
                if prog or line:
                    details += f" (prog={prog}, line={line})"
                return True, details
        except Exception:
            pass
        return False, ""

    # ---------------------- Lifecycle Hooks ----------------------

    def start(self):
        super().start()
        print("🟢 Feature DensoRC8 started")

    def stop(self):
        print("🔴 Feature DensoRC8 stopped")
        super().stop()
